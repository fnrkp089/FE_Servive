# ❓ Question

## 질문

Q: 어떤 함수가 테스트 가능성이 있다고 할 수 있나요?

A: 테스트 가능성이 높은 코드들은 다음과 같다고 생각합니다.\
1\. 단일책임원칙. 즉 각 함수는 하나의 일만 수행해야합니다. 그럴 경우 테스트 하기 용이합니다.\
2\. 순수함수일 경우엔 항상 동일한 출력을 반환하고 부작용이 없기 때문에 테스트 하기 쉽습니다\
3.의존성: 외부 객체에 의존할 경우 해당 의존성을 처리해야합니다. 예를들면 가짜(Mock)를 만들어서 주입해야합니다.\
4\. 모듈화: 코드들을 재사용 가능한 모듈로 분리할경우 각 모듈을 독립적으로 테스트하기 쉽습니다.



Q: XHTML과 HTML의 차이를 알려주세요

A:기본적으로 둘다 웹페이지를 만들기 위해 사용하는 마크업 언어입니다.\
차이점을 말씀드리자면 HTML은 문법이 유연하고,  태그를 닫지 않거나 중첩되어있는 태그들의 순서를 잘못 넣어도 페이지가 잘 작동합니다.\
그러나 XHTML의 경우에는 HTML 4.0을 XML문법으로 재정의했기 때문에 좀더 엄격합니다\
모든 요소는 반드시 닫혀있어야하고, 태그는 소문자로 작성되어야하고 속성값은 항상 따옴표로 묶여있어야 하는등, 좀더 HTML보다 엄격하지만, 이 규칙들로 인해 안정성과 호환성을 높일수 있습니다.

하지만 HTML5의 등장으로, HTML이 XHTML보다 많이 사용하기 시작했으며 XHTML의 많은 기능과 HTML의 유연성을 가지게 되었습니다.



Q: XHTML과 XML의 차이점에 대해 말해주세요

A: XML의 경우에는 데이터를 저장하고 전송하는데 사용되는 언어로 설계되었습니다. 즉  텍스트 기반의 데이터를 구조적으로 표현하고, 이를 다른 시스템과 다른 언어에서 쉽게 사용하도록 하는것이 목적입니다.\
그러나 XHTML의 경우에는 웹페이지의 구조와 내용을 표현하는데 많이 사용합니다.\
\
XHTML은 HTML을 XML의 문법에 맞게 구성한 것이라 간단하게 말할수 있습니다.

결론적으론 XHTML은 웹페이지의 구조와 내용을 정의하고 표현하는데 사용되고, XML의 경우에는 다양한 분야에서 데이터의 저장과 전송을 위해 사용됩니다.



Q: HTML과 HTML5의 차이는 무엇인가요?

HTML5는 HTML의 최신 버전이고, 많은 편의 기능들이 존재합니다.

1. 멀티미디어 요소: HTML5의 경우에는 비디오, 오디오 같은 새로운 태그들로 인해 외부 플러그인을 사용하지않고 멀티미디어 컨텐츠를 직접 웹페이지에 보여줄수 있습니다.
2. 그래픽: 캔버스 태그를 이용하여 웹페이지에서 직접 그래픽을 그릴수 있습니다.
3. 구조: 헤더,푸터,아티클, 섹션과 같은 새로운 태그들을 사용하여 웹페이지의 구조를 좀더 의미있게 표현할수 있고, 이는 웹페이지를 파싱하거나 해석하는데 많은 도움을 줍니다.
4. 저장: 웹브라우저의 로컬 저장소를 지원하게 되어 쿠키보다 더 많은 데이터를 웹브라우저에 저장할수 있습니다.
5. 웹소켓: HTML5는 실시간 통신을 가능하게 해주는 웹소켓을 도입했습니다.
6. 접근성: 몸이 불편한 사람들을 위한 접근성이 많이 향상되었습니다

Q: 의미있게 표현한다는게 무슨 뜻인가요?

A: 위에서 말씀드린것처럼 헤더,푸터,아티클,섹션,네비와 같은 태그들은 각각 특정한 의미를 가지고 웹페이지의 각각 어떤 부분이 어떤 역활을 하는지 명확하게 표현할수있습니다.

예를들면 헤더와 푸터는 각각 웹페이지의 위와 아래를 나타내며, 네비는 페이지의 네비게이션메뉴를 나타내는것과 같이 웹페이지의 구조가 더욱 명확해지고 웹페이지가 보다 '의미있는' 표현을 보여줍니다. 이를 사용하면 검색엔진최적화에도 도움이 됩니다.



Q: 웹 접근성에 대해 더 말해주시겠어요?

A:웹 접근성은 한마디로 어떠한 사용자든 웹사이트와 웹 어플리케이션에 동등한 위치에서 접근하고 이를 이용할수 있음을 말합니다. 즉 장애를 가진 사람들도 다양한 환경에서 거의 동등한 경험을 느낄수 있도록 하는것입니다.\
예를들면 다음과 같습니다

1. 시각장애: 이미지에 대체 텍스트를 붙이거나, 명확하게 콘텐츠를 구조화합니다
2. 청각장애: 멀티미디어 컨텐츠에 자막이나 수화를 제공합니다



Q: 웹 접근성을 위해 어떤 일들을 해보았나요?

A: 대체 텍스트와 색상 대비를 사용해 봤습니다.



Q: 함수 선언문과 화살표 함수에 대한 차이점을 설명해주세요

A: 둘다 함수를 정의하는 두 가지 방법입니다. \


**1. 함수 선언문(Function Declaration)**

함수 선언문은 전통적인 방법으로 함수를 정의합니다.

```javascript
function myFunction(a, b) {
  return a + b;
}
```

**2. 화살표 함수(Arrow Function)**

화살표 함수는 ES6(ES2015)에서 도입된 새로운 방식으로 함수를 정의하는 문법입니다.

```javascript
const myFunction = (a, b) => a + b;
```

이 두 함수 정의 방식은 문법적으로 다르며, 또한 다음과 같은 동작 차이도 있습니다.

*   **'this' 키워드의 바인딩**

    함수 선언문에서 'this' 키워드는 함수가 호출되는 컨텍스트에 따라 다르게 바인딩됩니다. 반면에 화살표 함수에서 'this'는 항상 그 함수를 둘러싼 (즉, 그 함수가 정의된) 렉시컬 컨텍스트에 바인딩됩니다. 이 차이는 특히 메서드나 이벤트 핸들러 등에서 중요합니다.
* > 화살표 함수는 THIS가 없습니다! 그렇기 때문에 상위 렉시컬 컨텍스트를 찾습니다!
*   **생성자 함수로 사용**

    함수 선언문으로 정의한 함수는 'new' 키워드를 사용하여 생성자 함수로 사용할 수 있습니다. 그러나 화살표 함수는 생성자 함수로 사용할 수 없습니다. 이는 화살표 함수가THIS가 없기 때문입니다.
*   **'arguments' 객체**

    함수 선언문에서는 'arguments'라는 특별한 변수를 사용하여 함수에 전달된 모든 인자에 접근할 수 있습니다. 그러나 화살표 함수에서는 'arguments' 객체를 사용할 수 없습니다.
*   **명시적인 'return'**

    함수 선언문에서는 항상 'return' 문을 사용하여 값을 반환해야 합니다. 반면에 화살표 함수에서는 중괄호({}) 없이 식을 바로 쓰면 그 식의 결과가 자동으로 반환됩니다. 하지만 중괄호를 사용하여 복수의 문장을 쓰는 경우에는 명시적인 'return' 문을 사용해야 합니다.

Q: Return이 없으면 함수가 아닌가요?

A: 리턴문이 없는 함수도 여전히 함수입니다. 자바스크립트에서 리턴문이 없거나 리턴만 존재할 경우엔 undefined로 반환합니다. \
이는 자바스크립트 언어의 설계단에서 결정된 이유인데, 이렇게 하는 이유는 여러가지 이유가 있습니다. 그중 한 이유는 항상 일관된 타입을 가져갈 수 있도록하여, 함수 호출의 결과를 다른 표현식의 일부로 사용하거나 변수에 할당하는것이 가능하도록 합니다.\
\
Q:`const makeName = (isMentor) => { if(isMentor) { return ‘woody’; } } makeName(false)` 값은?

A:

`makeName(false)`의 호출 결과는 `undefined`입니다.

이유는 다음과 같습니다:

* `makeName` 함수는 `isMentor` 인자가 `true`일 때만 문자열 'woody'를 반환합니다.
* 만약 `isMentor`가 `false`라면, 함수의 `if` 문이 실행되지 않고, 함수는 어떠한 `return` 문도 실행하지 않고 종료됩니다.
* JavaScript에서 `return` 문이 없는 함수는 자동으로 `undefined`를 반환합니다. 따라서 `isMentor`가 `false`일 때 `makeName` 함수는 `undefined`를 반환합니다.

Q: this의 역할에 대해 설명해주세요

A:&#x20;

`this`는 JavaScript에서 특별한 키워드로, 함수가 호출되는 컨텍스트(즉, "소유자"나 "주체")를 참조합니다. `this`의 값은 함수가 어떻게 호출되었는지에 따라 달라집니다.

1.  **메서드에서의 `this`**

    객체의 메서드 내에서 `this`를 사용하면, `this`는 그 메서드를 소유하고 있는 객체를 가리킵니다.

    ```javascript
    const person = {
      name: 'Alice',
      greet: function() {
        console.log('Hello, ' + this.name);
      }
    };

    person.greet();  // 출력: "Hello, Alice"
    ```

    여기서 `greet` 메서드 내의 `this`는 `person` 객체를 참조합니다.\

2.  **단독 함수에서의 `this`**

    단독 함수(즉, 어떤 객체에도 연결되지 않은 함수)에서 `this`를 사용하면, `this`는 전역 객체를 가리킵니다. 브라우저 환경에서 전역 객체는 `window`입니다. (그러나 strict 모드에서는 `this`가 `undefined`입니다)

    ```javascript
    function myFunction() {
      console.log(this);
    }

    myFunction();  // 출력: Window {...} (브라우저 환경에서)
    ```


3.  **생성자에서의 `this`**

    생성자 함수에서 `this`는 그 생성자에 의해 생성된 새로운 객체를 참조합니다.

    ```javascript
    function Person(name) {
      this.name = name;
    }

    const alice = new Person('Alice');
    console.log(alice.name);  // 출력: "Alice"
    ```

    여기서 `Person` 생성자 내의 `this`는 새로 생성된 객체를 참조합니다.\

4.  **`call`, `apply`, `bind`로 명시적으로 설정한 `this`**

    `call`, `apply`, `bind`와 같은 메서드를 사용하면 함수가 호출될 때 `this`의 값이 무엇인지 명시적으로 지정할 수 있습니다.

    ```javascript
    function greet() {
      console.log('Hello, ' + this.name);
    }

    const person = {name: 'Alice'};

    greet.call(person);  // 출력: "Hello, Alice"
    ```

    이 경우, `greet` 함수 내의 `this`는 `person` 객체를 참조합니다.\

5.  **화살표 함수에서의 `this`**

    화살표 함수에서 `this`는 그 함수를 둘러싼 렉시컬(즉, 정적) 컨텍스트에 바인딩됩니다. 이는 화살표 함수가 선언된 시점에서의 `this` 값을 가져온다는 의미입니다.

    ```javascript
    const person = {
      name: 'Alice',
      greet: function() {
        setTimeout(() =>
    ```



Q: 암시적 바인딩과 명시적 바인딩의 차이점을 말해주세요.

A: This는 함수가 호출되는 컨텍스트에 따라 다른 값을 가르킨다 이전에 설명했습니다.

이때 This가 가르키는 객체를 결정하는 방법을 바인딩이라 합니다.\
그중 암시적 바인딩과, 명시적 바인딩이 있는데 각각의 차이점은 다음과 같습니다.

1.  **암시적 바인딩(Implicit Binding):**

    암시적 바인딩은 함수가 호출되는 컨텍스트에서 `this`가 어떤 것을 가리키는지를 "암시"하게 됩니다. 이는 주로 메소드 호출에서 볼 수 있습니다. 메소드를 호출할 때, `this`는 그 메소드를 호출한 객체를 가리킵니다.

    ```javascript
    const obj = {
      name: 'Lee',
      greet: function() {
        console.log(`Hello, ${this.name}`);
      }
    };

    obj.greet();  // 출력: "Hello, Lee"
    ```

    위 예제에서 `obj.greet()`를 호출할 때, `greet` 메서드 내부의 `this`는 `obj`를 가리킵니다. 이렇게 호출 컨텍스트에 따라 `this`가 자동으로 바인딩되는 것을 암시적 바인딩이라고 합니다.\

2.  **명시적 바인딩(Explicit Binding):**

    `call`, `apply`, `bind`와 같은 메서드를 사용하여 `this`를 특정 객체에 명시적으로 바인딩할 수 있습니다. 이들 메서드를 사용하면 함수가 호출되는 컨텍스트와 상관없이 `this`가 가리키는 값을 직접 지정할 수 있습니다.

    ```javascript
    function greet() {
      console.log(`Hello, ${this.name}`);
    }

    const obj = {name: 'Lee'};

    greet.call(obj);  // 출력: "Hello, Lee"
    ```

    위 예제에서 `greet.call(obj)`를 실행하면, `greet` 함수 내부의 `this`는 `obj`를 가리킵니다. 이처럼 `this`를 직접 지정하는 방식을 명시적 바인딩이라고 합니다.

Q: 생성자 함수는 어떤 역활을 하나요?

A: 생성자 함수는 말그대로 자바스크립트에서 객체를 생성하는데 사용됩니다.\
일반적으로 첫 글자를 대문자로 작성하여 다른 함수와 구별합니다.\
생성자 함수는 기본적으로 `new`  키워드와 함께 호출되고, 호출의 결과로 새로운 객체를 생성하고 초기화 합니다.\
\
생성자 함수는 다음과 같은 특징이 있습니다.

1. **객체의 생성**: 생성자 함수는 새로운 객체를 생성합니다. 함수가 `new` 키워드와 함께 호출되면, JavaScript 엔진은 새로운 빈 객체를 생성하고, 그 객체를 `this`로 설정한 다음, 함수 본문을 실행합니다.
2. **객체의 초기화**: 생성자 함수는 새로 생성된 객체의 속성을 초기화하는 데 사용됩니다. 함수 본문에서 `this` 키워드를 사용하여 객체의 속성을 설정할 수 있습니다.
3. **객체의 반환**: 생성자 함수는 자동으로 새로 생성된 객체를 반환합니다. `return` 문을 명시적으로 작성하지 않아도 됩니다. (그러나 특정 객체를 반환하도록 `return` 문을 명시적으로 작성하면, 그 객체가 대신 반환됩니다)

Q: 콜백함수 개념에 대해 말해주세요

A: 콜백 함수는 함수를 매개변수로 받아 특정 작업이 끝나고 호출되는 함수를 뜻합니다.\
즉 일례로  어떤 작업의 결과를 다른 코드와 비동기적으로 공유할 수 있도록 사용됩니다.

비동기 프로그래밍 패턴에서 핵심적인 역활을 하기도 합니다. 자바스크립트는 이전에도 설명 드렸다 시피 단일 스레드 언어이기 때문에 비동기 처리가 중요한 역활을 합니다. 그래서 콜백 함수를 사용하면 시간이 오래걸리는 작업들을 백그라운드로 넘겨 처리하고 그 작업이 완료되면 콜백 함수를 실행하여 결과를 처리 할수 있습니다.\
\
Q: This가 바라보는 대상이 달라지는 상황이 있는데 이유는 무엇일까요?

A: 이전에 말했듯. this키워드가 가르키는 대상은 여러가지 이유에 따라 틀려집니다. 예를들면 다음과 같습니다.\


1. **전역 컨텍스트 또는 함수 내에서**: 전역 컨텍스트(함수 외부)에서 `this`는 전역 객체를 참조합니다. 웹 브라우저에서는 `window`가 되며, Node.js에서는 `global`이 됩니다. 그러나 일반 함수 내에서 `this`를 사용하면 엄격 모드(strict mode)에 따라 다릅니다. 엄격 모드에서는 `this`가 `undefined`가 되며, 엄격 모드가 아닌 경우에는 전역 객체를 참조합니다.
2. **메서드 내에서**: 객체의 메서드로 호출된 함수 내에서 `this`는 해당 메서드를 호출한 객체를 참조합니다.
3. **생성자 함수 내에서**: `new` 키워드를 사용하여 생성된 새 객체 내에서 `this`는 새로 생성된 객체를 참조합니다.
4. **`call`, `apply`, `bind`를 사용할 때**: 이러한 함수를 사용하여 함수를 호출하면, 첫 번째 매개변수로 전달된 객체가 `this`의 값이 됩니다.
5. **화살표 함수 내에서**: 화살표 함수는 자신만의 `this`를 가지지 않습니다. 대신 화살표 함수 내의 `this`는 상위 스코프의 `this`를 가리킵니다.

Q: this와 실행컨텍스트는 어떤 관계일까요?

A: this와 실행컨텍스트는 매우 밀접한 관계를 가지고있다 말해도 과언이 아닙니다.

실행 컨텍스트는 실행되는 코드의 환경을 나타내는 개념입니다. 즉 변수,함수선언,스코프체인 그리고 this키워드의 정보도 포함합니다.

자바스크립트에서는 함수가 실행될때마다 새로운 실행컨텍스트가 생성되고 이는 실행컨텍스트 스택에 쌓입니다. 즉 현재 실행중인 코드에 대한 컨텍스트는 스택의 맨 위에 위치하게 되는것이지요.

this키워드는 생성된 실행 컨텍스트의 일부이고, 그 값은 함수 호출 방식에 따라 달라집니다.

* **메서드 호출**: 객체의 메서드를 호출할 때, `this`는 해당 메서드를 호출한 객체를 참조합니다.
* **함수 호출**: 단순히 함수를 호출하면, `this`는 전역 객체를 참조하거나 엄격 모드(strict mode)에서는 `undefined`가 됩니다.
* **생성자 호출**: `new` 키워드를 사용해 함수(생성자)를 호출하면, `this`는 새로 생성된 객체를 참조합니다.
* **`call`, `apply`, `bind` 호출**: 이 메서드들을 통해 함수를 호출하면, `this`는 첫 번째 매개변수로 전달된 객체를 참조합니다.

따라서 실행 컨텍스트는 this값이 결정되는 환경을 제공하고, this는 그 환경에 따라 동적으로 결정됩니다.



Q:스택에 대해 설명해 주시겠어요?

A: 스택은 말그대로 CS에서 사용되는 자료구조중 하나입니다. \
마지막으로 들어간 항목이 처음으로 나오는 Last-in First-out 특성을 가지고 있습니다.

스택은 두가지 주요 연산이 존재합니다

1. `push`: 스택의 맨 위에 항목을 추가합니다.
2. `pop`: 스택의 맨 위에 있는 항목을 제거하고 그 값을 반환합니다.

JavaScript에서도 실행 컨텍스트 스택을 사용하여 함수 호출을 관리합니다. 함수가 호출되면 해당 함수의 실행 컨텍스트가 스택에 push 되고, 함수가 완료되면 해당 실행 컨텍스트는 스택에서 pop 됩니다.\
