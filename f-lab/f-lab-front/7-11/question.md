# ❓ Question

Q: 콜백 함수에 대해 말해주세요

A: 코어자바스크립트에서 콜백함수는 제어권을 다른 함수에게 넘겨준 함수라 말하고있습니다.\
즉 함수 A의 제어권을 다른 함수(메소드 포함)B에게 넘겨주었을때, A를 콜백함수라 합니다.\
그렇기 때문에 A함수는 B함수의 내무 로직에 따라 실행되고 this도 B함수 내부 로직에 의해 결정됩니다.

* 콜백 함수 A의 호출 시점은 함수 B가 결정한다.
* 콜백 함수 A의 인자로 넘겨줄 값과 그 순서도 함수 B가 결정한다.
* 콜백 함수 A의 this 또한 함수 B가 결정할 수 있다

&#x20;Q 메타 태그로 할 수 있는 일들에 대해 말해주세요

A: HTML에서 `<meta>` 태그는 웹 페이지의 메타데이터를 정의하는 데 사용됩니다. \
메타데이터는 실제로 웹 페이지에서 표시되지 않지만, 브라우저, 검색 엔진, 다른 웹 서비스에 웹 페이지에 대한 정보를 제공합니다.

예를들어 다음과 같은 것들이 있습니다.\
**charset:** 이 속성은 웹 페이지의 문자 인코딩을 지정합니다. 예를 들어, `<meta charset="UTF-8">`은 웹 페이지가 UTF-8 문자 인코딩을 사용하도록 지정합니다.

위와같이 문자 인코딩이나 웹페이지 설명 또는 뷰포트와 같이 다른 많은 정보들과 설정을 정의할수 있습니다.

&#x20;Q:  시멘틱 웹이란 무엇인가요?

A: 시멘틱 웹이란 WWW의 확장판이라 할수 있습니다. 즉 인터넷 데이터를 기계가 읽을수 있도록 하는것으로,\
데이터를 언어학적으로 해석이 가능하도록 합니다.\
즉 웹 상에 있는 모든 데이터를 기계가 읽을수 있게 만드는 작업이라 볼 수 있습니다.

시멘틱 웹이 중요한 이유는, 검색엔진 최적화에도 중요합니다.

#### 예시 <a href="#undefined" id="undefined"></a>

**시멘틱 태그 사용**\


```c
<header></header>
<section>
	<article>
		<figure>
			<img>
			<figcaption></figcaption>
		</figure>
	</article>
</section>
<footer></footer>
```

**시멘틱 태그 사용 X**

```c
<div id="header"></div>
<div class="section">
	<div class="article">
		<div class="figure">
			<img>
			<div class="figcaption"></div>
		</div>
	</div>
</div>
<div id="footer"></div>
```

> **`<img>` 태그를 사용하는 것과 `<div>` 태그에 `background-image` 속성을 추가하는 것.**\
> **두 가지 방법의 차이점과 각각 어떠한 경우에 사용하면 좋은지 설명해보세요**\
> \
> 웹 문서를 시멘틱 웹으로 만들고 싶다면 img 태그를 사용하는게 좋다. `<img>` 태그에는 여러가지 요소가 있는데, 그 중 `alt` 요소는 웹 문서의 접근성을 강화시켜준다. 시각장애인들도 읽을 수 있기 때문이다.\
> 그러므로 검색엔진에게 내가 올린 이미지 요소를 알려주고 싶다면 시멘틱한 `img` 태그를 사용하는게 좋다.
>
> 만약 이미지를 장식 요소로 사용하고 싶다면, `background-image` 속성을 사용해라. 시멘틱하진 않기 때문에 검색엔진이 인식할 수 없는 단점이 있지만 `img` 태그보다는 좀 더 이미지를 자유롭게 처리할 수 있다.\
> 예를 들어 이미지 위에 텍스트를 얹히고 싶을 때는 `img` 태그보다는 `background-image`를 사용하는게 좋다. 또한 `background`는 `background-size` 같이 다양한 파생 요소가 있기 때문에 이미지를 더 잘 꾸밀 수 있다.

Q: 클로저와 스코프의 밀접한 관계에 대해 말해주세요

A: 자바스크립트에서 둘은 매우 밀접한 관계를 가지고 있습니다.

스코프는 변수의 접근과, 생존기간을 결정하는 범위이며, 전역,함수, 블록스코프가 있고 \
변수는 선언된 위치와 스코프의 종류에 따라 접근범위가 결정됩니다.

클로저는 함수 내부에서 선언한 변수르 함수 외부에서도 접근 할 수 있게 해주는 자바스크립트의 특성중 하나인데,

함수는  선언될때 자신이 생성된 렉시컬스코프(어휘적환경)을 기억하게 됩니다. 이는 함수의 상위 스코프를 포함하고 호출되는 곳에 상관없이 동일합니다.\
그렇기 때문에 함수는 자신이 생성되었던 환경에서의 변수들에게 접근할수 있는데 이를 클로저라 합니다.\
즉 클로저는 함수와 그 함수가 선언된 렉시컬 스코프의 조합을 뜻하며, 렉시컬 스코프에는 해당 함수의 범위와 범위 안에 있는 변수들이 포함됩니다.

그렇기 때문에 함수가 실행되서도 이전에 접근했던 스코프의 변수를 참조할수 있는 이유는 클로저 떄문이라 할수있습니다.



Q: 인스턴스는 무엇인가요?

A: 인스턴스는 클래스나 생성자를 기반으로 해서 만들어진 객체입니다.\
\
Q: 자바스크립트에서 클래스와 인스턴스는 다른언어와 어떻게 다를까요?

A: 자바스크립트는 본디 프로토타입 기반의 객체 지향 언어입니다.\
자바와 C++다르게 구조적으로 틀리며 다른 객체로부터 속성을 상속받을수 있는 프로토 타입 객체를 가집니다.\
class가 도입된 후로 다른 언어처럼 객체 지향 프로그래밍을 사용하는 친숙함을 얻을수 있으나 차이점이 존재합니다.\


1. 자바스크립트의 클래스는 사실 함수입니다. 자바스크립트의 클래스는 "클래스"라는 새로운 객체 타입을 만드는 것이 아니라, 기존의 함수를 통해 객체를 만드는 프로토타입 기반 상속 모델에 대한 문법적인 설탕(syntactic sugar)일 뿐입니다. 즉, 클래스 문법도 내부적으로는 프로토타입 체인을 사용합니다.
2. 클래스 메서드는 기본적으로 열거할 수 없습니다. 이는 `Object.keys(MyClass.prototype)` 등을 사용해 클래스 메서드를 열거하려고 하면 아무 것도 반환하지 않음을 의미합니다. 이는 ES6의 `class` 문법이 내부적으로 `Object.defineProperty`를 사용하기 때문입니다.
3. 클래스는 호이스팅(hoisting)이 일어나지 않습니다. 즉, 클래스를 선언하기 전에 사용하려고 하면 ReferenceError가 발생합니다. 이는 함수 선언문과는 대조적입니다.
4. 자바스크립트의 클래스는 정적 메서드와 인스턴스 메서드를 모두 지원하지만, 정적 속성과 인스턴스 속성을 직접 지원하지는 않습니다. 이는 최근의 자바스크립트 제안을 통해 개선되고 있습니다.\


> 자바스크립트의 클래스 선언은 호이스팅(hoisting)되지 않습니다.
>
> 호이스팅이란 변수와 함수의 선언이 그들의 스코프에서 코드 실행 이전에 메모리에 할당되는 자바스크립트의 동작 방식을 의미합니다. 변수의 경우 선언과 초기화가 분리되어 선언이 호이스팅되고, 초기화는 원래 코드 상의 위치에서 이루어집니다. 함수 선언의 경우, 선언과 함께 정의(함수 본문)까지 호이스팅됩니다.
>
> 그러나 클래스 선언은 이와 다르게 동작합니다. 클래스 선언문은 호이스팅되지 않습니다. 즉, 클래스를 사용하려면 먼저 클래스를 선언해야 합니다. 그렇지 않으면 ReferenceError가 발생합니다. 이는 클래스가 `let`과 `const` 선언과 유사하게 블록 스코프를 가지며, 클래스 선언문과 클래스 표현식이 호이스팅되지 않는 이유입니다.
>
> 다음은 이를 나타내는 예제 코드입니다:
>
> ```javascript
> const p = new Polygon(); // ReferenceError: Polygon is not defined
>
> class Polygon {}
> ```
>
> 위의 코드에서는 Polygon 클래스를 선언하기 전에 인스턴스를 생성하려 했기 때문에 ReferenceError가 발생합니다. 이는 자바스크립트에서 클래스 선언이 호이스팅되지 않기 때문입니다.



Q
