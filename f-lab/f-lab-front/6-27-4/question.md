# ❓ Question

Q: var와 let의 차이를 설명해주세요

A: `var`와 `let`은 JavaScript에서 변수를 선언하는 두 가지 방법입니다. \
이 둘 사이의 주요 차이점은 스코프와 호이스팅에 있습니다.

**1. Scope(범위):** `var`는 함수 범위(function scope)를 가지는 반면, \
`let`은 블록 범위(block scope)를 가집니다.

함수 범위란, `var`로 선언된 변수가 자신이 선언된 함수의 범위 내에서만 사용될 수 있음을 의미합니다. \
만약 `var` 변수가 함수 외부에서 선언되었다면, 그 변수는 전역 변수가 되어 전체 스크립트에서 사용할 수 있습니다.

블록 범위란, `let`으로 선언된 변수가 자신이 선언된 블록, 즉 중괄호 `{}`로 둘러싸인 코드 블록 내에서만 사용될 수 있음을 의미합니다.

**2. Hoisting(호이스팅):** `var`와 `let`은 모두 호이스팅이라는 JavaScript의 동작 방식에 의해 처리되지만, 그 방식이 다릅니다.

호이스팅이란 변수나 함수의 선언이 그들의 스코프에서 실행 가능한 코드가 실행되기 이전에 메모리에 할당되는 JavaScript의 동작 방식을 의미합니다.

`var`로 선언된 변수는 호이스팅에 의해 스코프의 최상단으로 끌어올려집니다. 그 결과, 선언 전에도 해당 변수에 접근할 수 있게 됩니다. 이때, 변수는 `undefined`로 초기화됩니다.

반면에 `let`으로 선언된 변수도 호이스팅되지만, 스코프의 최상단으로 끌어올려지지 않습니다. 그래서 `let`으로 선언된 변수를 선언하기 전에 참조하려고 하면 ReferenceError를 발생시킵니다.

* TDZ:

> TDZ는 Temporal Dead Zone의 약자로, JavaScript에서 `let`과 `const` 키워드를 사용해 선언된 변수들이 호이스팅(hoisting)되지만, 그들이 실제로 선언된 위치까지의 코드 영역을 지칭합니다. 이 영역에서 해당 변수들에 접근하려고 시도하면 ReferenceError가 발생합니다.
>
> JavaScript의 실행 컨텍스트는 두 단계로 나뉩니다:
>
> 1. 생성 단계 (Creation phase)
> 2. 실행 단계 (Execution phase)
>
> 생성 단계에서는 변수와 함수 선언들이 메모리에 저장(hoisting)되지만, `let`과 `const`로 선언된 변수들은 아직 초기화되지 않은 상태입니다. 이런 변수들은 코드 실행 시점에서 실제로 선언된 위치까지 도달할 때까지 초기화되지 않으며, 이러한 영역이 바로 TDZ입니다.
>
> 실제로 선언된 위치에 도달하면, 변수들은 해당 값으로 초기화되고, 이후로는 변수에 접근하거나 값을 할당하는 데 문제가 없게 됩니다.
>
> 다음 코드는 TDZ를 보여줍니다:
>
> ```javascript
> console.log(myVar); // undefined
> console.log(myLet); // ReferenceError: myLet is not defined
>
> var myVar = 'I am a var';
> let myLet = 'I am a let';
> ```
>
> 위 코드에서 `var`로 선언된 `myVar`는 호이스팅되어 `undefined`로 초기화됩니다. 그러나 `let`으로 선언된 `myLet`은 TDZ에 있으므로 접근하려고 하면 ReferenceError가 발생합니다. 이것이 TDZ의 주요 개념입니다. 이런 방식은 JavaScript에서 `let`과 `const`의 동작을 보다 예측 가능하게 만드는 데 도움을 줍니다.



Q:

```javascript
function example() {
  var x = 10;
  let y = 20;

  if (true) {
    var x = 30;
    let y = 40;
    console.log(x); // 30
    console.log(y); // 40
  } 

  console.log(x); //30
  console.log(y); //20
}
—------------------------------------------
var x = 10;
var x = 20;
console.log(x); //20

let y = 10;
let y = 20; // Syntax error


```

A: `var`는 함수 레벨 스코프를 가지며, `let`은 블록 레벨 스코프를 가집니다.\
&#x20;`var`의 경우, 가장 가까운 부모 함수의 범위 내에서 어디서든 접근할 수 있습니다. 반면에 `let`의 경우, 변수가 선언된 블록 내에서만 접근 가능합니다.

```javascript
javascriptCopy codefunction example() {
  var x= 10;
  let y = 20;
  if(true){
    var x =30;
    let y =40;
    console.log(x); // 30
    console.log(y); // 40
  }
  console.log(x); // 30
  console.log(y); // 20
}
```

코드를 실행하면, 첫 번째 `console.log(x)`는 `var`가 선언된 스코프 내부에 있으므로, `x`는 30입니다. 두 번째 `console.log(y)`는 `let`이 선언된 블록 스코프 내부에 있으므로, `y`는 40입니다.

그러나, `if`문 바깥의 `console.log(x)`에서는 `var x`의 가장 최근 값이 출력되므로, `x`는 30입니다. 마지막 `console.log(y)`는 `let y`가 선언된 바깥 스코프에서 실행되므로, `y`는 20입니다.

두번째의 답은 다음과  같습니다.

`var` 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 가능하며, 마지막으로 할당된 값이 변수의 최종 값이 됩니다. 반면에, `let` 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 불가능합니다.

```javascript
var x = 10;
var x = 20;
console.log(x); // 20

let y =10;
let y =20; // Uncaught SyntaxError: Identifier 'y' has already been declared
```

따라서, `console.log(x);`는 '20'을 출력하고, `let y = 20;`는 이미 'y'가 선언되었다는 문법 오류(SyntaxError)를 발생시킵니다.&#x20;

JavaScript에서 `let`은 한 스코프 내에서 동일한 변수를 두 번 선언하려고 하면 오류를 발생시키는 엄격한 변수 선언 방식입니다.&#x20;



Q: 왜 let을 var 대신 써야할까요?

A:&#x20;

`var` 대신 `let`을 사용해야 하는 이유는 몇 가지 중요한 차이점 때문입니다. `let` 키워드는 `var` 키워드의 몇 가지 단점을 해결하고자 도입되었습니다.

1. **Block Scope:** `let`은 블록 범위(block scope)를 가집니다. 이는 중괄호 `{}`로 둘러싸인 블록 내에서만 변수가 유효하다는 것을 의미합니다. 이에 반해, `var`는 함수 범위(function scope)를 가집니다. 이 차이 때문에 `let`을 사용하면 코드가 더욱 예측 가능해지고, 이로 인해 버그를 방지할 수 있습니다.
2. **No Variable Hoisting:** `let`으로 선언된 변수는 호이스팅되지 않습니다. 즉, 선언되기 전에는 접근할 수 없습니다. `var`로 선언된 변수는 선언 전에도 접근이 가능한데, 이는 변수가 'undefined' 상태일 때 실수로 접근하는 문제를 초래할 수 있습니다.
3. **No Re-declaration:** `let`은 같은 스코프 내에서 동일한 변수를 두 번 선언하는 것을 금지합니다. 반면에 `var`는 동일한 스코프 내에서 동일한 변수를 여러 번 선언할 수 있습니다. 이것은 실수로 동일한 이름의 변수를 두 번 선언하더라도 오류를 일으키지 않으므로 버그를 초래할 수 있습니다.

Q: 그럼 Var를 아예 쓰지 말아야 할까요?

A:그것은 상황에 따라 틀립니다.

대부분의 경우에서는 `var`를 사용하지 않아도 큰 문제가 되지 않습니다. 실제로, ES6부터는 `let`과 `const`가 `var`의 대안으로 도입되었고, 이들은 `var`의 주요 단점들을 해결하려는 목적으로 설계되었습니다. 그러나 `var`를 전혀 사용하지 않으면 다음과 같은 경우에서의 유연성을 잃게 될 수 있습니다:

1. **전역 변수 선언:** `var`를 이용해서 선언한 전역 변수는 `window` 객체의 속성이 됩니다. 반면 `let` 또는 `const`로 선언된 전역 변수는 `window` 객체의 속성이 되지 않습니다. 때문에 특정 경우에서 `window` 객체를 통해 전역 변수에 접근할 필요가 있을 때 `var`를 사용하는 것이 유용할 수 있습니다.
2. **함수 스코프:** `var`는 함수 스코프를 가집니다. 이는 특정 경우에 유용할 수 있습니다. 예를 들어, 루프 내에서 `var`로 선언된 변수가 루프의 각 반복이 아닌 함수 전체에 걸쳐 유지되어야 할 경우, `var`의 함수 스코프 특성이 도움이 될 수 있습니다.
3. **변수 호이스팅:** `var`로 선언된 변수는 선언 위치에 상관 없이 스코프의 상단으로 호이스팅됩니다. 이로 인해 `var` 변수는 선언 전에도 참조할 수 있습니다(`undefined` 값으로). 이런 호이스팅 특성은 특정 상황에서 유용하게 사용될 수 있습니다.

Q:const는 뭐에요?

A: `const`는 JavaScript에서 변수를 선언하는 한 가지 방법입니다. `const`는 상수를 선언하는 데 사용되며, 한 번 선언하고 값을 할당하면 그 값을 나중에 변경할 수 없습니다. 이는 `let`과 `var`가 선언한 변수와는 대조적입니다. `let`과 `var`로 선언한 변수의 값은 나중에 변경할 수 있습니다.

`const`의 또 다른 중요한 특징은 블록 스코프를 가진다는 것입니다. `const`로 선언된 변수는 그것이 선언된 블록(중괄호 `{}`로 둘러싸인 영역) 내에서만 접근 가능하고 사용할 수 있습니다.

아래는 `const` 사용의 예시입니다:

```javascript
const PI = 3.14159;
console.log(PI);  // 3.14159

PI = 3.14;  // TypeError: Assignment to constant variable.
```

위의 코드에서, `PI`라는 이름의 상수가 선언되고 값이 할당되었습니다. 이후에 `PI`의 값을 변경하려고 하면 JavaScript는 오류를 던집니다. 이는 `const`로 선언된 변수의 값은 변경할 수 없다는 원칙을 보여줍니다.

그러나 `const`로 선언된 객체나 배열은 예외적으로 내부 속성이나 요소를 변경할 수 있습니다. 이는 `const`가 변수의 전체 재할당을 막지만, 객체의 속성이나 배열의 요소에 대한 변경은 막지 않기 때문입니다.



Q: 객체의 속성이나 배열의 요소에 대한 변경은 막지 않기 때문이라고요?

A: 네&#x20;

`const` 키워드는 변수 자체의 재할당을 막지만, 객체의 속성이나 배열의 요소에 대한 변경은 막지 않습니다. 이 이유는 `const`가 메모리 주소에 바인딩하는 방식 때문입니다.

JavaScript에서 `const`로 선언된 객체나 배열은 그 변수가 가리키는 메모리 주소를 상수로 만듭니다. 즉, `const`는 그 변수가 새로운 객체나 배열, 또는 다른 데이터 타입의 값으로 재할당되는 것을 막습니다. 그러나 객체의 속성이나 배열의 요소는 해당 변수가 가리키는 메모리 주소 내에서 위치하므로, 이들의 값은 변경될 수 있습니다.



Q: const를 지향해야하는 이유가 뭘까요?

A: 거의 대동 소이하지만 `const`를 사용하는 것이 좋은 이유는 여러 가지가 있습니다.&#x20;

1. **변경 불가:** `const`로 선언된 변수는 재할당이 불가능합니다. 이는 코드가 복잡해질 때 실수로 변수 값을 변경하는 일을 방지해 줍니다. 변수가 바뀌지 않는다는 것을 확신할 수 있으면 코드를 이해하고 디버그하는 것이 더 쉬워집니다.
2. **코드 읽기 쉬움:** `const`를 사용하면 해당 변수가 프로그램 실행 도중에 변하지 않는다는 것을 명확하게 알려줍니다. 이것은 코드를 읽는 사람에게 변수의 용도를 명확하게 전달하고, 이 변수가 변경되지 않아야 함을 확신시켜 줍니다.
3. **임시 불변성:** `const`로 선언된 객체나 배열은 재할당은 불가능하지만, 내부의 속성이나 요소는 변경 가능합니다. 이는 불변성(immutability)을 부분적으로 적용할 수 있게 해주는 좋은 방법입니다. 이는 버그를 줄이고 코드를 안전하게 만드는 데 도움이 될 수 있습니다.
4. **블록 스코프:** `const`는 블록 스코프를 가지므로, 변수는 선언된 블록 내에서만 유효합니다. 이는 `var`의 함수 스코프와 비교하여 변수의 가시성을 제한하고, 이름 충돌을 방지하는 데 도움이 됩니다.



Q:Remix 에서는 모든 변수를 let으로만 선언합니다 왜 그런지 생각해 보시겠어요?

A: `let`만을 사용하는 이유는 다양할 수 있지만, 일반적으로는 다음과 같은 이유로 선택될 수 있습니다:

1. **Simplicity:** `let`과 `const`를 혼용하는 것은 어떤 변수가 변경 가능한지를 계속 추적해야하는 복잡성을 가져올 수 있습니다. 모든 것을 `let`으로 만들면, 이러한 추적이 필요 없으므로 코드가 단순해질 수 있습니다.
2. **Flexibility:** `let`으로 선언된 변수는 나중에 필요에 따라 값을 변경할 수 있습니다. 반면 `const`로 선언된 변수는 재할당이 불가능합니다. 모든 변수를 `let`으로 선언함으로써, 필요에 따라 코드를 자유롭게 변경할 수 있는 유연성을 얻을 수 있습니다.
3. **Avoiding Potential Errors:** JavaScript는 `const`가 아닌 `let` 또는 `var`로 선언된 변수에 값을 할당하는 것을 허용하며, 이는 실수로 변수 값을 변경하는 가능성을 줄여줍니다. 모든 변수를 `let`으로 선언하면 이러한 실수를 방지할 수 있습니다.

이러한 이유들이 존재한다고 생각됩니다.

\
Q:호이스팅 과정에서 let과 const는 뭐로 할당될까요?

A: JavaScript에서 변수는 선언과 초기화, 그리고 할당의 세 단계를 거칩니다.

1. **선언(Declaration)**: 변수가 컴퓨터 메모리에 공간을 차지하도록 만드는 과정입니다.
2. **초기화(Initialization)**: 선언된 변수에 기본값을 부여하는 과정입니다. `var` 변수는 `undefined`로 자동 초기화되지만, `let`과 `const` 변수는 초기화되지 않습니다.
3. **할당(Assignment)**: 변수에 특정 값을 할당하는 과정입니다.

호이스팅(Hoisting)은 JavaScript에서 변수와 함수 선언이 자동으로 스코프의 최상단으로 끌어올려지는 특성을 나타냅니다. 이는 실행 컨텍스트의 생성 단계에서 일어납니다.

`var`로 선언된 변수는 호이스팅되었을 때 `undefined`로 초기화됩니다.&#x20;

그러나 `let`과 `const`로 선언된 변수는 선언은 호이스팅되지만 초기화는 호이스팅되지 않습니다. 이는 실행 컨텍스트의 코드 실행 단계에서 변수 선언의 위치에 도달했을 때 일어나므로, `let`과 `const` 변수에 접근하려고 하면 `ReferenceError`가 발생합니다. 이 구간을&#x20;

임시적 사각지대(Temporal Dead Zone, TDZ)라고 부릅니다.

따라서, `let`과 `const` 변수는 호이스팅 과정에서 아무 값으로도 초기화되지 않습니다. 그들은 선언된 코드의 위치에서 처음으로 초기화되며, 그 이전에는 TDZ에 있습니다.



Q: html은 무엇일까요?

A: HTML(HyperText Markup Language)은 웹 페이지의 구조를 만들고 내용을 표현하는 데 사용되는 표준 마크업 언어입니다.&#x20;

HTML은 웹 브라우저가 웹 페이지를 어떻게 표현하고 사용자와 어떻게 상호작용할지를 이해할 수 있게 해줍니다.

HTML 문서는 여러 "요소"로 구성되며, 이 요소들은 웹 페이지의 다양한 부분을 나타냅니다. 예를 들어, `<p>` 요소는 단락을, `<h1>` 요소는 제목을, `<a>` 요소는 하이퍼링크를 나타냅니다. 이러한 요소들은 종종 "태그"라고 불리는 꺽쇠괄호(`<>`) 안에 포함된 명령어를 사용하여 표시되며, 태그는 특정 요소가 어디에서 시작하고 어디에서 끝나는지를 나타냅니다.

HTML은 웹 페이지의 구조와 콘텐츠를 설명하지만, 디자인이나 스타일링은 CSS(Cascading Style Sheets)가 담당하며, 복잡한 기능이나 상호작용은 JavaScript가 처리합니다. 이 세 가지 기술(HTML, CSS, JavaScript)은 웹 개발의 기본적인 구성요소이며, 현대의 웹사이트는 대부분 이 세 가지 기술을 기반으로 작동합니다.



Q: HTML 은 엄격하지 않나요?

A:  HTML은 웹 페이지 구조를 정의하는 마크업 언어로, XML이나 XHTML과 비교했을 때 문법적인 엄격성이 상대적으로 낮습니다. 이는 HTML이 "forgiving"(용인하는) 마크업 언어로 설계되었기 때문입니다.

즉, HTML은 개발자가 문법 규칙을 완벽하게 따르지 않거나, 태그를 올바르게 닫지 않는 등의 오류가 있는 코드를 만나더라도, 이를 최대한 해석하고, 오류를 자동으로 수정하려고 시도합니다. 이러한 특성은 웹 페이지가 여전히 보여지고 기능하게 하는 한편, 웹 개발자가 실수를 만날 때 좀 더 유연하게 대처할 수 있게 합니다.

그러나, 이는 HTML 코드에 오류가 있을 때 원하지 않는 결과를 초래할 수도 있으며, 이러한 오류는 디버깅하기 어려울 수 있습니다. 또한, 잘못된 HTML 코드는 웹 접근성 문제를 야기하거나, 웹 크롤러가 페이지를 제대로 이해하지 못하는 문제를 야기할 수 있습니다.

따라서, HTML이 비교적 문법적으로 엄격하지 않다고는 하지만, 가능한 한 깨끗하고 올바른 HTML 코드를 작성하는 것이 좋습니다. 이는 웹 접근성, SEO(검색 엔진 최적화), 그리고 코드 유지 관리성을 향상시키는 데 도움이 됩니다.



Q: HTML에서 DocType은 뭘까요?

A: `<!DOCTYPE>`은 HTML 문서의 맨 처음에 위치하며, 문서 형식 선언(Document Type Declaration)이라고도 부릅니다. 이는 웹 브라우저에게 문서의 HTML 버전을 알려주는 역할을 합니다. 이로써 브라우저는 어떤 방식으로 페이지를 렌더링해야 하는지 결정할 수 있습니다.

`<!DOCTYPE>` 선언이 없거나 잘못된 경우, 웹 브라우저는 "quirks mode"라고 불리는 하위 호환성 모드로 전환하게 됩니다. 이 모드에서 브라우저는 오래된 웹 사이트들이 여전히 제대로 보일 수 있도록 일부 오래된 렌더링 규칙을 사용하게 됩니다. 그러나 이는 최신 CSS와 JavaScript 표준을 완벽하게 지원하지 않으므로, 가능한 항상 `<!DOCTYPE>`을 사용하는 것이 좋습니다.



Q: 자바스크립트 내에서 함수란 무엇일까요?

A: 자바스크립트에서 함수(function)는 특정 작업을 수행하는 코드 블록이라고생각합니다

함수를 정의한 다음, 함수를 호출하면 해당 코드 블록이 실행됩니다. \
함수는 프로그램의 코드를 모듈화하고 재사용하기 쉽게 만드는 중요한 도구입니다.



Q: 그러면 함수는 특정한 작업을 수행하면, 값을 반환하지않나요?

A:  네, 함수는 특정 작업을 수행하고 값을 반환할 수도 있습니다.

\
Q: 잘 만들어진 함수의 기준은 무엇일까요?

A:&#x20;

1. **단일 책임 원칙(Single Responsibility Principle, SRP):** 함수는 한 가지 명확한 작업을 수행해야 합니다. 함수가 여러 가지 작업을 동시에 수행하면 코드의 가독성과 유지보수성이 저하될 수 있습니다. 함수가 작고 집중적인 작업을 수행하도록 유지하는 것이 좋습니다.
2. **명료하고 의미 있는 이름:** 함수의 이름은 함수가 무엇을 수행하는지 명확하게 나타내야 합니다. 함수 이름은 동사로 시작하여 함수의 목적이나 동작을 알 수 있도록 지어야 합니다.
3. **매개변수와 반환 값의 명확성:** 함수의 매개변수는 함수의 작업에 필요한 입력 값을 명확하게 나타내야 합니다. 함수의 반환 값은 함수가 어떤 결과를 돌려주는지 명확하게 표현해야 합니다.
4. **코드 재사용성:** 함수는 코드의 재사용성을 높이도록 설계되어야 합니다. 비슷한 작업을 여러 번 반복하지 않고 함수를 호출하여 필요한 작업을 수행할 수 있어야 합니다.
5. **의존성 관리:** 함수는 외부 상태나 다른 함수와의 의존성을 적절하게 관리해야 합니다. 함수가 의존하는 것들을 명시적으로 전달하거나, 함수 내부에서 필요한 리소스를 생성하고 소멸하는 책임을 가질 수 있어야 합니다.
6. **테스트 가능성:** 함수는 쉽게 테스트할 수 있어야 합니다. 작은 단위로 분리되고, 의존성을 명시적으로 주입하거나 대체할 수 있어야 테스트하기 용이합니다.
7. **가독성과 유지보수성:** 함수의 코드는 가독성이 높고, 읽기 쉽고, 유지보수하기 편해야 합니다. 주석이나 적절한 문서화도 필요한 경우 제공되어야 합니다.

이러한 기준을 충족하는 함수는 코드의 품질과 가독성을 향상시키며, 재사용성을 높이고 버그 발생 가능성을 줄여줍니다.



Q: CSS에서 Cascading의 뜻은 무엇일까요?

A: "Cascading"은 "단계별" 또는 "연속적인"이라는 의미를 가지고 있습니다. CSS에서 "Cascading"은 스타일 규칙의 적용 우선순위를 의미합니다.

CSS는 여러 스타일 규칙이 동일한 요소에 적용될 수 있는 상황에서 어떤 규칙이 우선되는지 결정해야 합니다. 이때 "Cascading" 원칙에 따라 규칙들은 특정한 우선순위와 상속 등의 규칙을 따라 계단식으로 적용됩니다.

"Cascading"은 다음과 같은 원칙을 기반으로 합니다:

1. **우선순위(Priority)**: CSS는 서로 다른 규칙이 동일한 요소를 선택할 경우, 규칙에 우선순위를 부여하여 어떤 규칙이 적용될지 결정합니다. 우선순위는 선택자의 구체성(Specificity)과 중요성(Importance)에 따라 결정됩니다.
2. **상속(Inheritance)**: 일부 CSS 속성은 부모 요소에서 자식 요소로 상속될 수 있습니다. 이러한 속성은 자식 요소에 명시적으로 지정되지 않아도 부모 요소의 속성이 적용됩니다.
3. **구체성(Specificity)**: 선택자의 구체성은 스타일 규칙의 우선순위를 결정하는 데 사용됩니다. 구체성은 선택자의 종류, ID 선택자, 클래스 선택자, 태그 선택자의 사용 등을 고려하여 계산됩니다. 더 구체적인 선택자가 우선권을 가집니다.
4. **중요성(Importance)**: 스타일 규칙에 `!important` 키워드가 사용되면, 해당 규칙은 다른 모든 규칙보다 우선권을 갖게 됩니다.

"Cascading"은 CSS의 강력한 특성으로, 스타일을 더욱 유연하게 적용하고 스타일 규칙의 우선순위를 관리할 수 있게 합니다.
